---
title: "[Codeforces] CF2193D Monster Game 题解"
published: 2026-02-09
description: "Codeforces 2193D Monster Game 题解"
tags: [OI, Codeforces, 题解]
category: OI
draft: false
---

# 题解：CF2193D Monster Game
## 思路

使用贪心方法。

首先要把剑的威力 $a_i$ 降序排序，在 $x$ 最大的情况下通过关卡，之后我们遍历每个 $b_i$，在使 $x$ 尽量大的情况下枚举每一个关卡，最后输出得分的最大值 $max(ans, a_{sum} * i)$。

## 复杂度
 - 时间复杂度：$O(n\times{}log n)$
 - 空间复杂度：$O(n)$

## 代码

[**Codeforces** AC 记录](https://codeforces.com/contest/2193/submission/362120919)

```cpp
#include <bits/stdc++.h>
#define int long long //不开long long会WA
#define inc(i, l, r) for (int i = l; i <= r; i++)
#define dec(i, r, l) for (int i = r; i >= l; i--)
#define FAST_IO ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
/*===================祖传头模板=====================*/
const int N = 2e5 + 5; // 1 <= n <= 2e5
int a[N], b[N];
signed main()
{
    int t, n;
    cin >> t;
    while (t--)
    {
        cin >> n;
        inc(i, 1, n)
        {
            cin >> a[i];
        }
        inc(i, 1, n)
        {
            cin >> b[i];
        }
        sort(a + 1, a + n + 1, [](int x, int y){return x > y;}); // 降序排序
        int ans = INT_MIN, sum = 0;
        inc(i, 1, n) // 枚举b[i]
        {
            if (sum + b[i] > n)
                break; // 剑不够了就放弃
            sum += b[i]; // 累加通过第i关的剑的威力
            ans = max(ans, a[sum] * i); // 取最大得分
        }
        cout << ans << endl; // 输出答案
    }
    return 0;
}

```